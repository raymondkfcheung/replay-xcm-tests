import { Binary, createClient, Enum } from "polkadot-api";
import { withPolkadotSdkCompat } from "polkadot-api/polkadot-sdk-compat";
import { getWsProvider } from "polkadot-api/ws-provider/web";
import { paseo } from "@polkadot-api/descriptors";
import {
    XcmV3Junction,
    XcmV3Junctions,
    XcmV3MultiassetFungibility,
    XcmV3MultiassetAssetId,
    XcmV3WeightLimit,
    XcmVersionedAssets,
    XcmVersionedLocation,
} from "@polkadot-api/descriptors";
import { sr25519CreateDerive } from "@polkadot-labs/hdkd";
import { DEV_PHRASE, entropyToMiniSecret, mnemonicToEntropy, ss58Address } from "@polkadot-labs/hdkd-helpers";

const XCM_VERSION = 4;

// npx papi add paseo -w wss://paseo-rpc.n.dwellir.com
// https://docs.polkadot.com/develop/interoperability/xcm-runtime-apis/#dry-run-call
async function main() {
    // Connect to the Paseo relay chain
    const client = createClient(
        withPolkadotSdkCompat(getWsProvider("wss://paseo-rpc.n.dwellir.com")),
    );

    const api = client.getTypedApi(paseo);

    const popParaID = 4001;
    const entropy = mnemonicToEntropy(DEV_PHRASE);
    const miniSecret = entropyToMiniSecret(entropy);
    const derive = sr25519CreateDerive(miniSecret);
    const alice = derive("//Alice");
    const userPublicKey = alice.publicKey;
    const userAddress = ss58Address(userPublicKey);
    const idBeneficiary = Binary.fromBytes(userPublicKey);

    // Define the origin caller
    // This is a regular signed account owned by a user
    const origin = Enum("system", Enum("Signed", userAddress));

    // Define a transaction to transfer assets from Polkadot to Pop Network using a Reserve Transfer
    const tx: any = api.tx.XcmPallet.limited_reserve_transfer_assets({
        dest: XcmVersionedLocation.V3({
            parents: 0,
            interior: XcmV3Junctions.X1(
                XcmV3Junction.Parachain(popParaID), // Destination is the Pop Network parachain
            ),
        }),
        beneficiary: XcmVersionedLocation.V3({
            parents: 0,
            interior: XcmV3Junctions.X1(
                XcmV3Junction.AccountId32({
                    // Beneficiary address on Pop Network
                    network: undefined,
                    id: idBeneficiary,
                }),
            ),
        }),
        assets: XcmVersionedAssets.V3([
            {
                id: XcmV3MultiassetAssetId.Concrete({
                    parents: 0,
                    interior: XcmV3Junctions.Here(), // Native asset from the sender. In this case PAS
                }),
                fun: XcmV3MultiassetFungibility.Fungible(120000000000n), // Asset amount to transfer
            },
        ]),
        fee_asset_item: 0, // Asset used to pay transaction fees
        weight_limit: XcmV3WeightLimit.Unlimited(), // No weight limit on transaction
    });

    // Execute the dry run call to simulate the transaction
    const dryRunResult: any = await api.apis.DryRunApi.dry_run_call(
        origin,
        tx.decodedCall,
        XCM_VERSION,
    );

    // Extract the data from the dry run result
    const {
        execution_result: executionResult,
        emitted_events: emmittedEvents,
        local_xcm: localXcm,
        forwarded_xcms: forwardedXcms,
    } = dryRunResult.value;

    // Extract the XCM generated by this call
    const xcmsToPop = forwardedXcms.find(
        ([location, _]: any) =>
            location.type === "V4" &&
            location.value.parents === 0 &&
            location.value.interior.type === "X1" &&
            location.value.interior.value.type === "Parachain" &&
            location.value.interior.value.value === popParaID, // Pop network's ParaID
    );
    const destination = xcmsToPop[0];
    const remoteXcm = xcmsToPop[1][0];

    // Print the results
    const resultObject = {
        execution_result: executionResult,
        emitted_events: emmittedEvents,
        local_xcm: localXcm,
        destination: destination,
        remote_xcm: remoteXcm,
    };
    console.dir(resultObject, { depth: null });

    client.destroy();
}

main().catch(console.error);